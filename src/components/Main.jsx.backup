import React, { useState, useRef, useEffect } from "react";
import { PiCowFill } from "react-icons/pi";
import { MdUndo, MdTextFields, MdDownload, MdPlayArrow, MdClose, MdAdd, MdRotateLeft, MdRotateRight, MdContentCopy } from "react-icons/md";
import { BsTypeBold } from "react-icons/bs";
import { Rnd } from "react-rnd";
import html2canvas from "html2canvas";

const Main = () => {
  const [textColor, setTextColor] = useState("#8b5cf6");
  const [bgColor, setBgColor] = useState("#ffffff");
  const [font, setFont] = useState("Arial");
  const [bold, setBold] = useState(false);
  const [objects, setObjects] = useState([]);
  const [history, setHistory] = useState([]);
  const [selectedId, setSelectedId] = useState(null);
  const [selectedIds, setSelectedIds] = useState([]);
  const [isRecording, setIsRecording] = useState(false);
  const [isPlaying, setIsPlaying] = useState(false);
  const [recordingTime, setRecordingTime] = useState(0);
  const [animationKeyframes, setAnimationKeyframes] = useState({});
  const [isMultiSelectMode, setIsMultiSelectMode] = useState(false);
  const [showPreview, setShowPreview] = useState(false);
  const [previewImage, setPreviewImage] = useState(null);
  const [isPreviewPlaying, setIsPreviewPlaying] = useState(false);
  const previewPlaybackRef = useRef(null);
  const canvasRef = useRef(null);
  const recordingRef = useRef(null);
  const playbackRef = useRef(null);

  // Multi-selection functions
  const handleMultiSelect = (id) => {
    if (selectedIds.includes(id)) {
      setSelectedIds(selectedIds.filter(selectedId => selectedId !== id));
    } else {
      setSelectedIds([...selectedIds, id]);
    }
  };

  const clearSelection = () => {
    setSelectedId(null);
    setSelectedIds([]);
  };

  const isObjectSelected = (id) => {
    return selectedId === id || selectedIds.includes(id);
  };

  // Add new text
  const handleAddText = () => {
    const newObj = {
      id: Date.now(),
      type: "text",
      content: "New Text",
      x: 50,
      y: 50,
      width: 150,
      height: 50,
      rotation: 0,
      color: textColor,
      font,
      bold,
    };
    setObjects([...objects, newObj]);
    setHistory([...history, objects]);
    setSelectedId(newObj.id);
  };

  // Undo
  const handleUndo = () => {
    if (history.length > 0) {
      const prev = history[history.length - 1];
      setObjects(prev);
      setHistory(history.slice(0, -1));
      setSelectedId(null);
    }
  };

  // Upload media
  const handleUpload = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    const type = file.type.startsWith("video") ? "video" : "image";
    const newObj = {
      id: Date.now(),
      type,
      src: url,
      x: 50,
      y: 50,
      width: 200,
      height: 150,
      rotation: 0,
    };
    setObjects([...objects, newObj]);
    setHistory([...history, objects]);
    setSelectedId(newObj.id);
  };

  // Delete object
  const handleDelete = (id) => {
    setObjects(objects.filter((o) => o.id !== id));
    if (id === selectedId) setSelectedId(null);
  };

  // Rotate object
  const handleRotate = (id, delta) => {
    const updatedObj = { ...objects.find(o => o.id === id), rotation: ((o.rotation || 0) + delta) % 360 };
    setObjects(objects.map((o) => (o.id === id ? updatedObj : o)));
    captureKeyframe(id, updatedObj);
  };

  // Duplicate object
  const handleDuplicate = (id) => {
    const objToDuplicate = objects.find((o) => o.id === id);
    if (!objToDuplicate) return;

    const duplicatedObj = {
      ...objToDuplicate,
      id: Date.now(),
      x: objToDuplicate.x + 20,
      y: objToDuplicate.y + 20,
    };
    setObjects([...objects, duplicatedObj]);
    setHistory([...history, objects]);
    setSelectedId(duplicatedObj.id);
  };

  // Start/Stop Recording
  const handleStartRecording = () => {
    if (isRecording) {
      // Stop recording
      setIsRecording(false);
      if (recordingRef.current) {
        clearInterval(recordingRef.current);
      }
      return;
    }

    // Start recording - reset time for each new recording session
    setIsRecording(true);
    setRecordingTime(0); // Reset to 0 for each recording session
    // Don't clear animationKeyframes - keep existing animations
    
    recordingRef.current = setInterval(() => {
      setRecordingTime(prev => prev + 0.1);
    }, 100);
  };

  // Capture keyframe during recording
  const captureKeyframe = (id, obj) => {
    if (!isRecording) return;
    
    const newKeyframe = {
      objectId: id,
      time: recordingTime,
      x: obj.x,
      y: obj.y,
      width: obj.width,
      height: obj.height,
      rotation: obj.rotation || 0,
    };
    
    setAnimationKeyframes(prev => ({
      ...prev,
      [id]: [...(prev[id] || []), newKeyframe]
    }));
  };

  // Add keyframe manually
  const handleAddKeyframe = (id) => {
    const obj = objects.find(o => o.id === id);
    if (!obj) return;
    
    const newKeyframe = {
      objectId: id,
      time: recordingTime,
      x: obj.x,
      y: obj.y,
      width: obj.width,
      height: obj.height,
      rotation: obj.rotation || 0,
    };
    
    setAnimationKeyframes(prev => ({
      ...prev,
      [id]: [...(prev[id] || []), newKeyframe]
    }));
  };

  // Clear all animations
  const handleClearAnimations = () => {
    setAnimationKeyframes({});
    setRecordingTime(0);
    clearSelection();
  };

  // Play animation
  const handlePlay = () => {
    if (isPlaying) {
      setIsPlaying(false);
      clearSelection();
      if (playbackRef.current) {
        cancelAnimationFrame(playbackRef.current);
      }
      return;
    }

    // Reset objects to first keyframe positions
    setObjects(prevObjects => 
      prevObjects.map(obj => {
        const objKeyframes = animationKeyframes[obj.id] || [];
        if (objKeyframes.length > 0) {
          const firstKeyframe = objKeyframes[0];
          return {
            ...obj,
            x: firstKeyframe.x,
            y: firstKeyframe.y,
            width: firstKeyframe.width,
            height: firstKeyframe.height,
            rotation: firstKeyframe.rotation,
          };
        }
        return obj;
      })
    );

    clearSelection();
    setIsPlaying(true);
    const startTime = Date.now();
    
    const animate = () => {
      const elapsed = (Date.now() - startTime) / 1000;
      
      // Update object positions based on keyframes
      setObjects(prevObjects => 
        prevObjects.map(obj => {
          const objKeyframes = animationKeyframes[obj.id] || [];
          if (objKeyframes.length === 0) return obj;
          
          // Find surrounding keyframes
          let prevKeyframe = objKeyframes[0];
          let nextKeyframe = objKeyframes[objKeyframes.length - 1];
          
          for (let i = 0; i < objKeyframes.length - 1; i++) {
            if (elapsed >= objKeyframes[i].time && elapsed <= objKeyframes[i + 1].time) {
              prevKeyframe = objKeyframes[i];
              nextKeyframe = objKeyframes[i + 1];
              break;
            }
          }
          
          if (prevKeyframe && nextKeyframe && prevKeyframe.time !== nextKeyframe.time) {
            const progress = Math.min(1, Math.max(0, (elapsed - prevKeyframe.time) / (nextKeyframe.time - prevKeyframe.time)));
            // Smooth easing function
            const easedProgress = progress < 0.5 
              ? 2 * progress * progress 
              : 1 - Math.pow(-2 * progress + 2, 2) / 2;
            
            return {
              ...obj,
              x: prevKeyframe.x + (nextKeyframe.x - prevKeyframe.x) * easedProgress,
              y: prevKeyframe.y + (nextKeyframe.y - prevKeyframe.y) * easedProgress,
              rotation: prevKeyframe.rotation + (nextKeyframe.rotation - prevKeyframe.rotation) * easedProgress,
              width: prevKeyframe.width + (nextKeyframe.width - prevKeyframe.width) * easedProgress,
              height: prevKeyframe.height + (nextKeyframe.height - prevKeyframe.height) * easedProgress,
            };
          }
          
          return obj;
        })
      );
      
      // Get max time from all keyframes
      const maxTime = Math.max(...Object.values(animationKeyframes).flat().map(kf => kf.time));
      
      if (elapsed <= maxTime + 0.5) { // Add small buffer at the end
        playbackRef.current = requestAnimationFrame(animate);
      } else {
    
    if (elapsed <= maxTime + 0.5) { // Add small buffer at the end
      playbackRef.current = requestAnimationFrame(animate);
    } else {
      setIsPlaying(false);
      clearSelection();
    }
  };
  
  animate();
};

const dataUrl = canvas.toDataURL("image/png");
setPreviewImage(dataUrl);
setShowPreview(true);
} catch (error) {
  console.error('Error generating preview:', error);
  // Fallback: show preview without image capture
  setShowPreview(true);
} finally {
  document.body.removeChild(tempCanvas);
}

// ... (rest of the code remains the same)

/* Preview Modal */
{showPreview && (
  <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div className="bg-white rounded-lg shadow-xl p-6 max-w-4xl max-h-screen overflow-auto">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-xl font-bold text-gray-800">Preview</h2>
        <button
          onClick={() => setShowPreview(false)}
          className="text-gray-500 hover:text-gray-700 text-2xl leading-none"
        >
          Ã—
        </button>
      </div>
      <div className="border-2 border-gray-200 rounded">
        {previewImage ? (
          <img src={previewImage} alt="Preview" className="w-full h-auto" />
        ) : (
          <div 
            style={{
              backgroundColor: bgColor,
              width: "100%",
              height: "400px",
              position: "relative"
            }}
          >
            {objects.map((obj) => {
              return obj.type === "text" ? (
                <div
                  key={obj.id}
                  style={{
                    position: "absolute",
                    left: obj.x,
                    top: obj.y,
                    width: obj.width,
                    height: obj.height,
                    color: obj.color,
                    fontFamily: obj.font,
                    fontWeight: obj.bold ? "bold" : "normal",
                    fontSize: "18px",
                    transform: `rotate(${obj.rotation || 0}deg)`,
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center"
                  }}
                >
                  {obj.content}
                </div>
              ) : obj.type === "image" ? (
                <img 
                  key={obj.id}
                  src={obj.src} 
                  alt="" 
                  style={{
                    position: "absolute",
                    left: obj.x,
                    top: obj.y,
                    width: obj.width,
                    height: obj.height,
                    transform: `rotate(${obj.rotation || 0}deg)`,
                    objectFit: "contain"
                  }}
                />
              ) : (
                <video 
                  key={obj.id}
                  src={obj.src} 
                  style={{
                    position: "absolute",
                    left: obj.x,
                    top: obj.y,
                    width: obj.width,
                    height: obj.height,
                    transform: `rotate(${obj.rotation || 0}deg)`,
                    objectFit: "contain"
                  }}
                  autoPlay 
                  loop 
                  muted 
                />
              );
            })}
          </div>
        )}
      </div>
      <div className="mt-4 flex justify-end space-x-2">
        <button
          onClick={handlePreviewPlay}
          className={`px-4 py-2 ${isPreviewPlaying ? 'bg-red-600 hover:bg-red-700' : 'bg-green-600 hover:bg-green-700'} text-white rounded`}
        >
          {isPreviewPlaying ? (
            <>
              <MdClose size={14} />
              <span>Stop Preview</span>
            </>
          ) : (
            <>
              <MdPlayArrow size={14} />
              <span>Play Preview</span>
            </>
          )}
        </button>
        <button
          onClick={() => setShowPreview(false)}
          className="px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400"
        >
          Close
        </button>
        <button
          onClick={handleDownload}
          className="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700"
        >
          Download
        </button>
      </div>
    </div>
  </div>
)}
export default Main;